/**
 * Cloud control configuration.
 *
 * @column user_id 		the ID of the account owner
 * @column id 			the ID of the configuration
 * @column created		the creation date
 * @column modified		the modification date
 * @column enabled		a flag to mark the configuration as enabled for use by application or not
 * @column cname 		a name for the configuration
 * @column int_id 		the ID of the integration associated with this configuration
 * @column node_id 		the control node ID
 * @column control_id 	the control ID (does NOT support placeholders)
 * @column cref 		the cloud control reference
 * @column sident 		the cloud integration service identifier
 * @column sprops 		the cloud integration service properties
 */
CREATE TABLE solardin.cin_control (
	user_id			BIGINT NOT NULL,
	id				BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
	created			TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	modified		TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	enabled			BOOLEAN NOT NULL DEFAULT FALSE,
	cname			CHARACTER VARYING(64) NOT NULL,
	int_id 			BIGINT NOT NULL,
	node_id 		BIGINT NOT NULL,
	control_id 		CHARACTER VARYING(64) NOT NULL,
	cref			CHARACTER VARYING(4096),
	sident			CHARACTER VARYING(128) NOT NULL,
	sprops			JSONB,
	CONSTRAINT cin_control_pk PRIMARY KEY (user_id, id),
	CONSTRAINT cin_control_user_fk FOREIGN KEY (user_id)
		REFERENCES solaruser.user_user (id) MATCH SIMPLE
		ON UPDATE NO ACTION ON DELETE CASCADE,
	CONSTRAINT cin_control_int_fk FOREIGN KEY (user_id, int_id)
		REFERENCES solardin.cin_integration (user_id, id) MATCH SIMPLE
		ON UPDATE NO ACTION ON DELETE CASCADE
);

-- add index on node + control for fast lookup
CREATE INDEX IF NOT EXISTS cin_control_control_idx ON solardin.cin_control (node_id, control_id);


/**
 * Node instruction task configuration.
 *
 * @column user_id 		the ID of the account owner
 * @column id 			the ID of the configuration
 * @column enabled		a flag to mark the configuration as enabled for use by application or not
 * @column cname 		a name for the configuration
 * @column node_id		the associted node ID
 * @column topic 		the instruction topic
 * @column schedule 	a cron schedule or number of seconds
 * @column status 		task status, e.g. queued, executing, error
 * @column exec_at 		the next scheduled time for the task to execute
 * @column sprops 		task service properties
 * @column last_exec_at	last execution time
 * @column message		result message
 * @column rprops 		execution result properties
 */
CREATE TABLE solaruser.user_node_instr_task (
	user_id			BIGINT NOT NULL,
	id				BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
	enabled			BOOLEAN NOT NULL DEFAULT FALSE,
	cname			CHARACTER VARYING(64) NOT NULL,
	node_id 		BIGINT NOT NULL,
	topic 			CHARACTER VARYING(64) NOT NULL,
	schedule 		CHARACTER VARYING(64) NOT NULL,
	status 			CHARACTER(1) NOT NULL,
	exec_at 		TIMESTAMP WITH TIME ZONE NOT NULL,
	sprops			JSONB,
	last_exec_at	TIMESTAMP WITH TIME ZONE,
	message 		TEXT,
	rprops			JSONB,
	CONSTRAINT user_instr_task_pk PRIMARY KEY (user_id, id),
	CONSTRAINT user_node_instr_task_user_node_fk FOREIGN KEY (user_id, node_id)
		REFERENCES solaruser.user_node (user_id, node_id) MATCH SIMPLE
		ON UPDATE CASCADE ON DELETE CASCADE
);

-- indexes to speed up claim task query
CREATE INDEX user_node_instr_task_exec_idx ON solaruser.user_node_instr_task
	(exec_at) WHERE (status = 'q' AND enabled);


/**************************************************************************************************
 * FUNCTION solaruser.claim_node_instr_task()
 *
 * "Claim" an instruction task from the user_instr_task table that has a status of 'q'
 * and change the status to 'p' and return it. The tasks will be claimed from oldest to newest
 * based on the exec_at column.
 *
 * @return the claimed row, if one was able to be claimed
 */
CREATE OR REPLACE FUNCTION solaruser.claim_node_instr_task()
	RETURNS SETOF solaruser.user_node_instr_task LANGUAGE plpgsql VOLATILE ROWS 1 AS
$$
DECLARE
	rec solaruser.user_node_instr_task;

	-- include ORDER BY here to encourage user_instr_task_exec_idx to be used
	curs CURSOR FOR SELECT * FROM solaruser.user_node_instr_task t
			WHERE t.status = 'q'
			AND t.enabled
			AND t.exec_at <= CURRENT_TIMESTAMP
			ORDER BY t.exec_at
			LIMIT 1
			FOR UPDATE SKIP LOCKED;
BEGIN
	OPEN curs;
	FETCH NEXT FROM curs INTO rec;
	IF FOUND THEN
		UPDATE solaruser.user_node_instr_task SET status = 'p' WHERE CURRENT OF curs;
		rec.status = 'p';
		RETURN NEXT rec;
	END IF;
	CLOSE curs;
	RETURN;
END
$$;
