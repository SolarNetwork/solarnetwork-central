<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="net.solarnetwork.central.datum.dao.mybatis.GeneralNodeDatum">

	<!-- 
	   Input props:
			date_field            - the date field to query, e.g. 'day'
			date_field_agg        - the date field to aggregate on , e.g. 'month'
			
		Input params:
			filter.nodeIds        - array of node IDs
			filter.sourceIds      - array of source IDs
			range.startDate       - the start date (inclusive)
			range.endDate         - the end date (exclusive)
			range.localStartDate  - the local start date (inclusive)
			range.localEndDate    - the local end date (exclusive)
			filter.startDate      - the start date (inclusive)
			filter.endDate        - the end date (exclusive)
			filter.localStartDate - the local start date (inclusive)
			filter.localEndDate   - the local end date (exclusive)			
			
		Outputs:
			ts_start             - timestamptz
			local_date           - date (or timestamptz if date_field_agg == 'hour')
			node_id              - bigint
			source_id            - text
			jdata                - jsonb
	 -->
	<sql id="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum-from">
		FROM solardatum.node_source_time_rounded(
			#{filter.nodeIds,jdbcType=ARRAY,typeHandler=net.solarnetwork.central.dao.mybatis.type.LongArrayTypeHandler}::bigint[]
			, #{filter.sourceIds,jdbcType=ARRAY,typeHandler=net.solarnetwork.central.dao.mybatis.type.TextArrayTypeHandler}::text[]
			, '${date_field}'
			<choose>
				<when test="range != null">
					<choose>
						<when test="range.localStartDate != null">
							, #{range.localStartDate,typeHandler=net.solarnetwork.central.dao.mybatis.type.JodaLocalDateTimeTypeHandler,jdbcType=TIMESTAMP}::timestamp
							, #{range.localEndDate,typeHandler=net.solarnetwork.central.dao.mybatis.type.JodaLocalDateTimeTypeHandler,jdbcType=TIMESTAMP}::timestamp
						</when>
						<otherwise>
							, #{range.startDate,javaType=org.joda.time.DateTime,jdbcType=TIMESTAMP}::timestamp
							, #{range.endDate,javaType=org.joda.time.DateTime,jdbcType=TIMESTAMP}::timestamp
						</otherwise>
					</choose>
				</when>
				<otherwise>
					<choose>
						<when test="filter.localStartDate != null">
							, #{filter.localStartDate,typeHandler=net.solarnetwork.central.dao.mybatis.type.JodaLocalDateTimeTypeHandler,jdbcType=TIMESTAMP}::timestamp
							, #{filter.localEndDate,typeHandler=net.solarnetwork.central.dao.mybatis.type.JodaLocalDateTimeTypeHandler,jdbcType=TIMESTAMP}::timestamp
						</when>
						<otherwise>
							, #{filter.startDate,javaType=org.joda.time.DateTime,jdbcType=TIMESTAMP}::timestamp
							, #{filter.endDate,javaType=org.joda.time.DateTime,jdbcType=TIMESTAMP}::timestamp
						</otherwise>
					</choose>
				</otherwise>
			</choose>
		) r
		INNER JOIN <choose>
				<when test="'${date_field}' == 'hour'">
					solaragg.agg_datum_hourly
				</when>
				<when test="'${date_field}' == 'day'">
					solaragg.agg_datum_daily
				</when>
				<otherwise>
					solaragg.agg_datum_monthly
				</otherwise>
			</choose> datum ON 
			datum.node_id = ANY(r.node_ids)
			AND datum.source_id = ANY(r.source_ids)
			AND datum.ts_start &gt;= r.ts_start
			AND datum.ts_start &lt; r.ts_end
	</sql>

	<sql id="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum-agg">
		SELECT 
			date_trunc('${date_field_agg}', datum.ts_start::timestamp) AT TIME ZONE r.time_zone AS ts_start
			, (date_trunc('${date_field_agg}', datum.ts_start::timestamp) AT TIME ZONE r.time_zone)<if test="'${date_field_agg}' != 'hour'">::date</if> AS local_date
			, datum.node_id
			, datum.source_id
			<choose>
				<when test="combine != null">
					, solaragg.datum_agg_agg(jsonb_build_object(
						'jdata', solaragg.jdata_from_datum(datum),
						'jmeta', datum.jmeta) ORDER BY datum.ts_start) #> '{jdata,i}' AS jdata_i
					, solaragg.datum_agg_agg(jsonb_build_object(
						'jdata', solaragg.jdata_from_datum(datum),
						'jmeta', datum.jmeta) ORDER BY datum.ts_start) #> '{jdata,a}' AS jdata_a
					, solaragg.datum_agg_agg(jsonb_build_object(
						'jdata', solaragg.jdata_from_datum(datum),
						'jmeta', datum.jmeta) ORDER BY datum.ts_start) #> '{jdata,s}' AS jdata_s
					, solarcommon.json_array_to_text_array(
						solaragg.datum_agg_agg(jsonb_build_object(
							'jdata', solaragg.jdata_from_datum(datum),
							'jmeta', datum.jmeta) ORDER BY datum.ts_start) #> '{jdata,t}') AS jdata_t
				</when>
				<otherwise>
					, solaragg.datum_agg_agg(jsonb_build_object(
						'jdata', solaragg.jdata_from_datum(datum),
						'jmeta', datum.jmeta) ORDER BY datum.ts_start) -> 'jdata' AS jdata
				</otherwise>
			</choose>
		<include refid="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum-from"/>
		GROUP BY datum.node_id, datum.source_id, date_trunc('${date_field_agg}', datum.ts_start::timestamp) AT TIME ZONE r.time_zone
	</sql>
	
	<sql id="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum">
		SELECT 
			datum.ts_start
			, datum.local_date
			, datum.node_id
			, datum.source_id
			<choose>
				<when test="combine != null">
					, datum.jdata_i
					, datum.jdata_a
					, datum.jdata_s
					, datum.jdata_t
				</when>
				<otherwise>
					, solaragg.jdata_from_datum(datum) AS jdata
				</otherwise>
			</choose>
		<include refid="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum-from"/>
	</sql>
	
	<!-- Partial days -->
	
	<sql id="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Day-partial-ranges">
		<foreach collection="ranges" item="range" separator=") UNION ALL (" open="(" close=")">
			<choose>
				<when test="range.aggregation.toString() == 'Hour'">
					<include refid="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum-agg">
						<property name="date_field" value="hour"/>
						<property name="date_field_agg" value="day"/>
					</include>
				</when>
				<otherwise>
					<include refid="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum">
						<property name="date_field" value="day"/>
						<property name="date_field_agg" value="day"/>
					</include>
				</otherwise>
			</choose>
		</foreach>
	</sql>
	
	<select id="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Day-partial-count" resultType="long">
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-cte"/>
		SELECT count(datum.ts_start)
		FROM (		
			<include refid="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Day-partial-ranges"/>
		) datum
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-join"/>
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-group"/>
	</select>

	<select id="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Day-partial" resultMap="ReportingGeneralNodeDatumMatchResult" fetchSize="250" resultSetType="FORWARD_ONLY">
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-cte"/>
		SELECT
			<include refid="fragment-GeneralNodeDatum-aggregation-result"/>
		FROM (		
			<include refid="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Day-partial-ranges"/>
		) datum
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-join"/>
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-group"/>
		<include refid="fragment-findall-ReportingGeneralNodeDatum-order"/>
	</select>
	
	
	<!-- Partial months -->
	
	<sql id="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Month-partial-ranges">
		<foreach collection="ranges" item="range" separator=") UNION ALL (" open="(" close=")">
			<choose>
				<when test="range.aggregation.toString() == 'Hour'">
					<include refid="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum-agg">
						<property name="date_field" value="hour"/>
						<property name="date_field_agg" value="month"/>
					</include>
				</when>
				<when test="range.aggregation.toString() == 'Day'">
					<include refid="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum-agg">
						<property name="date_field" value="day"/>
						<property name="date_field_agg" value="month"/>
					</include>
				</when>
				<otherwise>
					<include refid="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum">
						<property name="date_field" value="month"/>
						<property name="date_field_agg" value="month"/>
					</include>
				</otherwise>
			</choose>
		</foreach>
	</sql>
	
	<select id="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Month-partial-count" resultType="long">
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-cte"/>
		SELECT count(datum.ts_start)
		FROM (		
			<include refid="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Month-partial-ranges"/>
		) datum
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-join"/>
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-group"/>
	</select>

	<select id="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Month-partial" resultMap="ReportingGeneralNodeDatumMatchResult" fetchSize="250" resultSetType="FORWARD_ONLY">
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-cte"/>
		SELECT
			<include refid="fragment-GeneralNodeDatum-aggregation-result"/>
		FROM (		
			<include refid="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Month-partial-ranges"/>
		) datum
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-join"/>
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-group"/>
		<include refid="fragment-findall-ReportingGeneralNodeDatum-order"/>
	</select>

	<!-- Partial years -->
	
	<sql id="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Year-partial-ranges">
		<foreach collection="ranges" item="range" separator=") UNION ALL (" open="(" close=")">
			<choose>
				<when test="range.aggregation.toString() == 'Day'">
					<include refid="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum-agg">
						<property name="date_field" value="day"/>
						<property name="date_field_agg" value="year"/>
					</include>
				</when>
				<when test="range.aggregation.toString() == 'Month'">
					<include refid="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum-agg">
						<property name="date_field" value="month"/>
						<property name="date_field_agg" value="year"/>
					</include>
				</when>
				<otherwise>
					<include refid="fragment-findall-ReportingGeneralNodeDatum-time-rounded-datum-agg">
						<property name="date_field" value="year"/>
						<property name="date_field_agg" value="year"/>
					</include>
				</otherwise>
			</choose>
		</foreach>
	</sql>
	
	<select id="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Year-partial-count" resultType="long">
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-cte"/>
		SELECT count(datum.ts_start)
		FROM (		
			<include refid="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Year-partial-ranges"/>
		) datum
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-join"/>
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-group"/>
	</select>

	<select id="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Year-partial" resultMap="ReportingGeneralNodeDatumMatchResult" fetchSize="250" resultSetType="FORWARD_ONLY">
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-cte"/>
		SELECT
			<include refid="fragment-GeneralNodeDatum-aggregation-result"/>
		FROM (		
			<include refid="findall-GeneralNodeDatum-ReportingGeneralNodeDatum-Year-partial-ranges"/>
		) datum
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-join"/>
		<include refid="fragment-findall-ReportingGeneralNodeDatum-combine-group"/>
		<include refid="fragment-findall-ReportingGeneralNodeDatum-order"/>
	</select>

</mapper>
